오픈소스의 소개 2
1) 오픈소스 성공 사례
    
    1. 각 분야 별 오픈소스 적용 성공 사례 
	1. 넥슨: IT 시스템 관리/모니터링/운영 (정보 시스템 분야) 
	2. 한양대학교: 모바일 스마트 캠퍼스 (모바일 분야) 
	3. GS샵: 오픈소스 기반 상품 추천 시스템 (클라우드&빅데이터 분야) 
	4. 핸드스튜디오: 오픈소스 기반 스마트 TV 앱 (임베디드 분야)

2) 오픈소스 기반 아키텍처
	1. 전략 및 계회 부분은 상업용 소프트웨어 아키텍처를 따름
	2. 기술 및 구현 부분은 오픈소스 소프트웨어의 아키텍처를 차용
	 1) 사용자 및 시장의 요구 사항 
	 2) 요구사항에 맞는 솔루션의 스펙을 정의하고 출시 일정, 타겟 고객 등을 결정
	 3) 제품 구현에 필요한 기반 오픈소스 기술과 컴포넌트를 선택하고 요구사항에 맞게 통합(패키지화)
     오픈소스 기반 솔루션 아키텍처 전략
	 1) 오픈소스에 부족한 제품 전략, 마케팅적인 부분을 회사가 가진 역량(브랜드, 영업/기술력 등)을 통해 보완
	 2) 오픈소스를 통해 구현에 필요한 시간을 단축하고, 저변이 넓은 검증된 기술을 통해 솔루션의 기반을 견고하게 함
	 3) 상용 솔루션이 필요로 하는 성능, 재사용성, 유연성 등을 쉽게 확보
	 4) 전략에 맞는 아키텍처를 수립하고 그에 맞는 오픈소스 컴포넌트들을 선택하여 패키지화(통합)

  - Hadoop 생태계란?
  : 하둡 생태계는 분산 프로그래밍 프레임워크를 이루고 있는 다양한 서브 프로젝트들의 모임이다.
 
     zookeeper
	: 분산 환경에서 서버들간에 상호 조정이 필요한 다양한 서비스를 제공하는 시스템입니다. 첫째, 하나의 서버에만 서비스가 집중되지 않도록, 서비스를 알맞게 분산하여 동시에 처리하게 해줍니다. 둘째, 하나의 서버에서 처리한 결과르 다른 서버들과도 동기화하여 데이터의 안정성을 보장해줍니다. 셋째, 운영 서버가 문제가 발생하여 서비스를 제공할 수 없을 경우, 다른 대기 중인 서버를 운영서버로 바꿔서 서비스가 중지 없이 제공되게 해줍니다. 넷째, 분산 환경을 구성하는 서버들의 환경설정을 통합적으로 관리해줍니다. (공식 사이트: http://zookeeper.apache.org/)
      Ooozie
	: 하둡 작업을 관리하는 워크플로우 및 코디네이터 시스템입니다. 자바 서블릿 컨테이너에서 실행되는 자바 웹 애플리케이션 서버이며, MapReduce 작업이나 Pig 작업 같은 특화된 액션들로 구성된 워크 플로우를 제어합니다. 참고로 2011년 7월에 아파치 인큐베이션에 포함됐습니다. (공식 사이트: http://incubator.apache.org/oozie)
   
     HBase
	: HDFS 기반의 칼럼 기반 데이터 베이스입니다. 구글의 BigTable 논문을 기반으로 개발됐습니다. 실시간 랜덤 조회 및 업데이트가 가능하며, 각 각의 프로세스들은 개인의 데이터를 비동기적으로 업데이트할 수 있습니다. 단, MapReduce는 일괄 처리 방식으로 수행됩니다. 트위터, 야후, 어도비 같은 해외 업체들이 HBase를 사용하고 있으며, 국내에서는 얼마 전 NHN이 모바일 메신저인 라인에 HBase를 적용한 시스템 아키텍처를 발표하였습니다. (공식 사이트: http://hbase.apache.org)
    
     Pig
	: 야후에서 개발되었으나 현재는 아파치 프로젝트에 속해있습니다. 복잡한 MapReduce 프로그래밍을 대체할 Pig Latin이라는 자체 언어를 제공합니다. MapReduce API를 매우 단순화시키고, SQL과 유사한 형태로 설계됐습니다. SQL과 유사하기만 할 뿐, 기존 SQL 지식을 활용하는 것이 어려운 편입니다. (공식 사이트: http://pig.apache.org)
    
     Hive
	: 하둡 기반의 데이터웨어하우징용 솔루션입니다. 페이스북에서 개발됐으며, 오픈 소스로 공개되며 주목을 받은 기술입니다. SQL과 매우 유사한 HiveQL이라는 쿼리를 제공합니다. 그래서 자바를 모르는 데이터 분석가들도 쉽게 하둡 데이터를 분석할 수 있게 도와줍니다. HiveQL은 내부적으로 MapReduce 잡으로 변환되어 실행됩니다. (공식 사이트: http://hive.apache.org)
    
     Mahout
	: 하둡 기반으로 데이터 마이닝 알고리즘을 구현한 오픈 소스입니다. 현재 분류 (classification), 클러스터링 (clustering), 추천 및 협업 필터링 (Recommenders/collaborative filtering), 패턴 마이닝 (Pattern Mining), 회귀 분석 (Regression), 차원 리덕션 (Dimension reduction), 진화 알고리즘 (Evolutionary Algorithms) 등 중요한 알고리즘을 지원하고 있습니다. Mahout을 그대로 사용할 수도 있지만, 자신의 비즈니스 환경에 맞게 최적화해서 사용하는 경우가 많습니다. (공식 사이트: http://mahout.apache.org)
    
     HCatalog
	: 하둡으로 생성한 데이터를 위한 테이블 및 스토리지 관리 서비스입니다. HCatalog의 가장 큰 장점은 하둡 에코 시스템들간의 상호 운용성 향상입니다. 예를 들어 Hive에서 생성한 테이블이나 데이터 모델을 Pig나 MapReduce에서 손쉽게 이용할 수가 있는 것입니다. 물론 그 전에도 에코 시스템간에 데이터 모델 공유가 불가능한 것은 아니었지만, 상당한 백엔드 작업이 필요했습니다. (공식 사이트: http://incubator.apache.org/hcatalog)

     Avro
	: RPC(Remote Procedure Call)과 데이터 직렬화를 지원하는 프레임워크입니다. JSON을 이용해 데이터 형식과 프로토콜을 정의하며, 작고 빠른 바이너리 포맷으로 데이터를 직렬화합니다. (공식 사이트: http://avro.apache.org)

     Chukwa
	: 분산 환경에서 생성되는 데이터를 HDFS에 안정적으로 저장시키는 플랫폼입니다. 분산된 각 서버에서 에이전트(agent)를 실행하고, 콜랙터(collector)가 에이전트로부터 데이터를 받아 HDFS에 저장합니다. 콜렉터는 100개의 에이전트당 하나씩 구동되며, 데이터 중복 제거 등의 작업은 MapReduce로 처리합니다. 야후에서 개발됐으며, 현재는 아파치 인큐베이션에 포함되어 있습니다. (공식 사이트: http://incubator.apache.org/chukwa)

     Flume
	: Chukwa 처럼 분산된 서버에 에이전트가 설치되고, 에이전트로부터 데이터를 전달받는 콜랙터로 구성됩니다. 차이점은 전체 데이터의 흐름을 관리하는 마스터 서버가 있어서, 데이터를 어디서 수집하고, 어떤 방식으로 전송하고, 어디에 저장할 지를 동적으로 변경할 수가 있습니다. 클라우드데라에서 개발됐으며, 현재는 아파치 인큐베이션에 포함되어 있습니다. (공식 사이트: http://incubator.apache.org/projects/flume.html)

     Scribe
	: 페이스북에서 개발한 데이터 수집 플랫폼이며, Chukwa와는 다르게 데이터를 중앙 집중 서버로 전송하는 방식입니다. 최종 데이터는 HDFS외에 다양한 저장소를 활용할 수 있으며, 설치와 구성이 쉽게 다양한 프로그램 언어를 지원합니다. HDFS에 저장하기 위해서는 JNI(Java Native Interface)를 이용해야 합니다. (공식 사이트: https://github.com/facebook/scribe)

     Sqoop
	: 대용량 데이터 전송 솔루션이며, 올해 4월 아파치의 top-level 프로젝트가 됐습니다. Sqoop은 HDFS, RDBMS, DW, NoSQL등 다양한 저장소에 대용량 데이터를 신속하게 전송할 수 있는 방법을 제공합니다. Oracle, MS-SQL, DB2 등과 같은 상용 RDBMS와 MySQL, PostgresSQL과 같은 오픈소스 RDBMS등을 지원합니다. (공식 사이트: http://sqoop.apache.org)

     Hiho
	: Sqoop과 같은 대용량 데이터 전송 솔루션이며, 현재 github에서 공개되어 있습니다. 하둡에서 데이터를 가져오기 위한 SQL을 지정할 수 있으며, JDBC 인터페이스를 지원합니다. 현재는 Oracle과 MySQL의 데이터 전송만 지원합니다. (공식 사이트: https://github.com/sonalgoyal/hiho)

     Impala
	: 클라우드데라에서 개발한 하둡 기반의 실시간 SQL 질의 시스템입니다. 맵리듀스를 사용하지 않고, 자체 개발한 엔진을 사용해 빠른 성능을 보여줍니다. 임팔라(Impala)는 데이터 조회를 위한 인터페이스로, HiveQL을 사용합니다. 수초 내에 SQL 질의 결과를 확인할 수 있으며, HBase와도 연동이 가능합니다. (https://github.com/cloudera/impala)

     Tajo
	: 고려대학교 정보통신대학 컴퓨터학과 DB연구실 박사 과정학생들이 주도해서 개발한 하둡 기반의 DW 시스템입니다. 2013년 아파치 재단의 인큐베이션 프로젝트로 선정되었습니다. 데이터 저장소는 HDFS를 사용하되, 표준DB언어인 SQL을 통해 실시간으로 데이터를 조회할 수 있습니다. Hive보다 2 ~ 3배 빠르며, 클라우드데라의 임팔라(Impala)와는 비슷한 속도를 보여줍니다. 임팔라가 클라우드데라의 하둡을 써야 하는 제약에 비해, 특정 업체 솔루션에 종속되지 않는 장점이 있습니다. (http://tajo.incubator.apache.org)

1. Rest API 기반 PaaS Cloud 아키텍처
    
    1-1) 지속적인 빌드
	문제 : 개발 산출물을 클라우드에 반영하여 지속적인 업그레이드
	해결 : jenkins를 통해 개발 산출물 자동 빌드 및 반영
    1-2) 시스템 Health 모니터링
	문제 ; 대규모 시스템에 대한 모니터링의 어려움
	해결 : collected를 통한 개별 시스템 모니터링 정보 수집, graphite/grafana를 통한 시각화
    1-3) 자동화된 Provisioning 및 구성 관리
	문제 : 신규 시스템 추가에 많은 시간 소요
	해결 : 신규 시스템 추가, 구성 변경, 새로운 개발 산출물 반영을 chef를 통해 관리
    1-4) 로그 수집 및 분석
	문제 : 장애 발생 시 산재된 각 시스템 로그 분석 어려움
	해결 : rsyslog + logstsh를 통해서 원격 로그를 중앙 수집하고, ElasticSearch를 통해 Indexing, Kibana를 통한 시각화

2. 스마트카(사물 인터넷)

    2-1) 데이터 수집 서버
	문제 : 불안정한 네트워크로 인한 단말 제어, 데이터 수집의 어려움
	해결 : Active MQ를 통한 MQTT 통신 및 Jboss Application Server 클러스터링 통한 확장성
    2-2) 데이터 디스커버리
	문제 : 배치 처리로 인한 분석 시간 지연
	해결 : ElasticSearch(or Splunk)를 통해 데이터 디스커버리 기능 제공
    2-3) 데이터 저장 및 DW
	문제 : 대용량 빅데이터 저장 및 관리
	해결 : Hadoop 스토리지에 저장하고 Hive를 통한 SQL 제공
    2-4) 데이터 분석
	문제 : 고가의 분석 시스템
	해결 : Pentaho ETL, OLAP 및 PostgreSQL DB를 통한 데이터 분석 및 마트 DB 생성

3. M2M 사물인터넷 데이터 수집

    3-1) 데이터 수집 Agent/Adapter
	문제 : 기계 장비에 부하를 주지 않는 가벼우면서도 빠른 통신 필요
	해결 : ZeroMQ를 통한 가볍고 빠른 통신, 장비에 따라 TCP, UDP 선택
    3-2) Complex Event Processing
	문제 : 실시간 데이터 패턴 감지의 어려움
	해결 : Drools Fusion을 CEP 기능 구현
    3-3) OSGi를 이용한 다양한 모듈 운용
	문제 : 모듈에 대한 의존 관계 및 동적인 업데이트의 어려움
	해결 : Apache Felix 기반의 OSGi 이용
    3-4) Low Latency 처리
	문제 : 일부 기계 제어의 경우 응답 시간 보장이 필요
	해결 : Realtime JVM을 통해 응답시간 보장
    3-5) 가상화를 통한 Provisioning
	문제 : 복잡한 컴포넌트들 설치/구성 때문에 신규 시스템 구축 어려움
	해결 : Linux KVM 가상화를 이용하여 VM 단위 Provisioning

4.VM 기반 NFV 제어 솔루션

    4-1) 웹 기반 인터페이스
	문제 : 웹 기반 UI 구현
	해결 : ExtJS 사용
    4-2) VM 제어 기능 구현 서버
	문제 : 다양한 VM 제어 기능 구현
	해결 : Python/Flask 기반 REST API 서버, Fabirc을 통해 원격 VM 제어
    4-3) VM Provisioning 및 관리
	문제 : VM 제어 방안 필요
	해결 : lib-vert 기반 Hypervisor 제어
    4-4) Graphite/Django 기반 모니터링 UI
	문제 : 다양한 모니터링 정보의 시각화
	해결 : Graphite / Django를 이용하여 그래프 랜더링

3) 산업과 오픈소스의 결합
    
    1) 인더스트리 발전 과정
	
	1차 산업혁명 – 물과 증기로 가동되는 제조설비 도입
	2차 산업혁명 – 노동분업화에 따라 전기설비에 의한 대량생산시대로 진입
	3차 산업혁명 – 전자제품과 IT의 사용을 통한 제조업의 자동화 확산
	4차 산업혁명 - 사이버폴리시스템(CPS) 기반
	인더스트리 4.0
	 2008년 금융 위기 이후, 선진국의 제조업 부활 정책 총공세 및 제조업의 중요성 재조명
	 ICT 기반 제 4차 산업혁명
	 사물인터넷, 빅데이터, 클라우드컴퓨팅, 스마트로봇 등 기반 기술의 동시다발적 발전
	 제조 생태계와 초 연결 사회 간의 실시간 연계, 소통이 가능
	 제조 강국의 세대교체 가속화, 상품 수출과 기술 서비스 접목 활성화

	>> 오픈소스 기반 ICT 기술을 통한 산업의 발전

    2) 오픈소스 산업계 적용 예 – Polarsys
	 Airbus와 Eclipse Foundation이 주도가 되어 안전과 관련된 산업 기기, 임베디드 소프트웨어 시스템을 오픈소스 기반으로 개발하기 위한 프로젝트
	 항공, 국방, 운송, 통신, 에너지, 의료 등에서 필요로 하는 개발 도구
	 국제적인 규제에 근거하여 요구사항 수집부터 개발, 테스트까지 제품에 대한 전체적인 lifecycle을 관리할 수 있는 도구
	 30 ~ 70년 유지보수가 가능해야 함 >> 개방형 오픈소스 소프트웨어의 필요성
	국내는 원천 기술보다는 활용/생산/설비 기술 >> 서비스로 발전 필요성

4) 접근 방법 및 프로세스
    
1) 오픈소스 참여 모델
     >> Developers – Community – Users – Potential Users

2) 오픈소스 적용 모델
	 OSS의 강자들은 활용 단위에 따라 다양한 방법으로 사업 경쟁력을 강화시킴
	 상용 SW와 OSS의 분류 체계는 유사하며, 완제품 수준의 대체와 연계가 핵심임
	 라이선스 이슈는 보통 소스 코드와 라이브러리 수준에서 결합 형태에 따라 달라짐

3) 오픈소스 프로젝트 찾기
	 오픈소스 소스 저장소(Repository)
  	: Github, BitBucket, Google Code, Code Project, SourceForge, Naver nForge

4) 오픈소스 소프트웨어 개발 방법론
  	 공동개발 방식으로 소프트웨어 개발
	 하나의 프로젝트 혹은 소프트웨어를 전세계에 흩어져 있는 다양한 사람들과 조직이 어우러져서 개발을 진행하는 방식
	 공통관심사를 갖는 사람들이 함께 특정 소프트웨어나 프로젝트를 개발하는 관계로자사의 개발과 투자 비용을 절감하고, 기업 외부의 인력과 기술을 내재화할 수 있는 특성이 있음
 
>> 외부 인력과 기술을 활용하여 개발 비용을 절감하기 위해서는 ,해당 기술을 이해하는 많은 외부 인력이 존재하고 이들이 오픈 소스 소프트웨어를 통해 자신의 기술과 능력을 공유할 정도의 환경과 규모가 필요

	 공동 개발 방식은 소위 네트워크 효과에 의해 크게 영향을 받는 개발 방식으로 특정 임계점 이상의 개발자가 소프트웨어 개발에 참여해야만 성공적으로 소프트웨어가 유지, 관리, 개발되는 특성이 있음.

5) Subversion 작업유형
   중앙 repository 내에서 로컬 복사 후 변경한 사본을 커밋하는 방식으로 진행
	 Create a local copy
	 Make changes
	 See what was changed in the repoistory in the meantime
	 Update your local copy
	 Resolve conflicts(Merge your changes)
	 Submit your changes

6) Git 작업 유형
	 기존의 버전 관리 시스템과는 다른 로컬 영역의 저장소의 2단계를 가짐
  	   명령어들을 로컬에서 실시하고 나중에 서버에 올리는 방식을 사용
  	   기존의 svn에서 commit이 소스를 수정하고, 저장소로 업로드하는 단계를 각각의 명령어로 분리하여 중간에 로컬에서 일하다가 저장소에 적용하기 전의 잠재적인 한 번의 단	  계를 거침
  	   한 번의 명령으로 바로 적용되는 SVN과는 달리 2번의 명령을 실행해야 마침내 서버에 있는 저장소로 업로드
 	    “git commit –a”의 명령을 통해서 다른 버전관리 프로그램들과 같이 이용하는 것도 가능

7) Git 기반 분산형 개발 아키텍처 
	 각 팀원의 역할을 분담해서 한 명은 통합을 전담으로 수행 
	 다른 개발자는 각자 부분 개발에 집중을 하는 식으로 역할 분담 
	 팀이 커질수록 복수의 repository를 쉽게 구성 가능 
	 하위 팀들을 묶어주는 통합 관리자, 그리고 전체를 통합하는 관리자로 더 세분화해서 구성하는 것이 가능

5) 오픈소스 고려 사항
1) 오픈소스 라이선스 – OSI 인증 70여 개 라이선스

2) 오픈소스 라이선스 – 특징(양면성)
	 자유 : 복제, 설치, 운영, 수정, 배포의 자유
  	   기존 소스 코드 및 라이브러리의 재사용으로 생산성 향상
  	   성숙한 OSS 커뮤니티의 프로젝트 적용으로 품질 보장
	 Copyleft : 공개되어 있는 소스 코드
  	   공개되어 있는 소스 코드를 통해 알고리즘과 로직을 분석하고 응용할 수 있어 설계자, 개발자, 테스터의 소프트웨어 기술력 증강
	 무료 : 내부 사용, 외부 판매
  	   TCO(Total Cost Ownership) 절감
  	   기술지원 및 유지보수 서비스를 기반으로 사업 가능
	 반환 의무 : 특정 OSS, 라이선스의 소스 코드 공개 의무
  	   GPL, LGPL, MPL, CPL, IBM, EPL, OSL, Qt 등이 해당됨
  	   연결된 소프트웨어의 소스 코드 공개의무가 발생
  	   비공개 SW가 OSS로 변경될 수 있음
  	   특허, 영업비밀, 핵심기술 등의 외부 유출 가능성 존재
	 저작권 : 저작권법에 따른 법적 권리 보장
  	   OSS 라이선스 미 준수 시 저작자와 분쟁 가능
  	   협력업체가 저작권 위반 시 협력업체가 책임을 지더라도 최종적으로 고객이 동의하지 않는 소스 코드 공개 등은 공급사의 부담이 됨

3) 오픈소스 라이선스 및 의무사항

	 주요 OSS 라이선스인 GPL, LGPL, CPL, MPL 등은 OSS 코드 뿐 아니라 사용자 코드 공개의무 발생
	 OSS를 활용하면서 공개하기 어려운 코드를 보호하기 위해서는 적절한 라이선스 관리가 필요함

 GPL ( General Public License )
   자유로운 사용, 복제 , 배포 및 수정
   저작권 표시, 보증책임이 없다는 표시, GPL 명시
   소프트웨어 수정 및 링크 시 모든 코드를 GPL에 의해 공개

 LGPL ( Lesser General Public License )
   자유로운 사용, 복제, 배포 및 수정
   저작권 표시, 보증책임이 없다는 표시, LGPL 명시
   소프트웨어 수정 및 링크 시 모든 코드를 LGPL에 의해 공개
   (단, 라이브러리 링크 시 공개하지 않음)

 MPL ( Mozilla Public License )
   자유로운 사용, 복제 , 배포 및 수정
   저작권 표시, 보증책임이 없다는 표시, MPL 명시
   특허 보복조항(특허 SW 사용시 특허권을 주장할 수 없음)
   소프트웨어 수정 및 링크 시 해당 파일을 공개

 EPL( Eclipse Public License )
   자유로운 사용, 복제, 배포 및 수정
   저작권 표시, 보증책임이 없다는 표시, EPL 명시
   특허 보복조항(특허 SW 사용시 특허권을 주장할 수 없음)
   소프트웨어 수정 및 링크 시 해당 파일을 공개

4) 오픈소스 전환 Best Practice
	 라이브러리 교체가 프레임워크 교체에 비해 쉬움 
	 운영 체제, 관리/모니터링 컴포넌트 적용 용이 
	 미들웨어(웹서버, 앱서버, Queue 등) 교체가 DB 교체에 비해 쉬움 
	 데이터 저장, 처리 등 전문/업무 영역은 범용적인 분야에 비해 부족 
	 사실상의 표준에 가까운 인지도 높은 오픈 소스 활용 
	 유연성과 민첩성 확보를 위한 범용적인 아키텍처의 중요성 
	 TCO 절감 및 ROI 극대화를 위한 내재화가 필수 오픈소스 전환 Best Practice

5) 오픈소스에 대한 부정적인 의견
	 상용 소프트웨어를 선택하는 것이 유리한 경우 
  	   상용의 사용 방법이 훨씬 쉬운 경우 
  	   상용이 사실상의 표준인 경우 
  	   상용의 지원이 우수하거나 기능이 더 풍부한 경우 
  	   SaaS 기반 서비스가 필요할 때 
  	   하드웨어 호환성이 우수한 경우(예: Window XP HW Driver 지원) 
  	   보증/책임보상이 중요한 경우 
	 경우에 따른 선택이 중요 
  	   기능이나 호환성 같은 명확히 우수한 요건의 경우에는 상용 선택이 유리 
  	   지원과 같은 비기능적인 요건의 경우에는 소스가 공개된 오픈소스가 유리할 수도 있음 
● 80 %는 오픈소스의 품질이 상용 제품보다 나은 것으로 평가

6) 오픈소스의 보안 
  	 Linux가 타 플랫폼에 비해서 안정적이라는 보고 
  	 제로데이어택(아직 밝혀지지 않은 버그를 이용한 공격) 시대라는 관점에서, 공개된 소스를 통해 문제점을 빨리 찾을 수 있는 오픈소스가 보안성 높음(Gartner) 
  	 소스가 공개되어 있어 투명하고 문제점 발견 시, 소수에 의해 주도되는 프로젝트에 비해 빠르게 해결 가능 오픈소스의 보안

5) 결론

 1) 강점 요소
	 전세계의 다양하고 많은 기업들이 기술 개밤에 참여
	 X86 시스템과 함께 높은 기술 경쟁력 및 시장 점유율 보유
	 가상화/클라우드 컴퓨팅 기반 기술을 제공하며 시스템 혁신 가능
	 국내외 기술지원 전문기업과 엔지니어가 많아지고 있음
  	약점 요소
	 오픈 소스에 대한 이해도, 생태계, 개발 프로세스 등에 대한 인식이 부족
	 정보 기획/ 운영 관점의 투자(초기교육, 컨설팅)가 필요한 분야
	 복잡한 라이선스 모델
  
2) 기회요소
	 핵심 기술에 대한 기술력(내재화)를 통한 경쟁사 우위
	 모바일/클라우드/IOT 등 다양한 분야에 대한 빠른 시장 접근
	 기술 도입 및 운용 비용의 절감
3) 위협요소
	 상용SW 벤더의 라이선스 관리 서비스(LMS)를 통해 법적 이슈를 만들어 지속적으로 Lock-in 시킴
	 기존의 IT 환경에 익숙한 관리자들의 반발
	 자체 기술력 부족 시 비용 절감 효과가 낮음
4) 오픈소스의 의미
	 개방형 기술을 통한 사실상의 표준 주도 
	 오픈소스를 활용한 기술과 서비스의 분리 
	 오픈소스는 시대적 흐름

6) 참고 문헌

위키피디아 
• https://ko.wikipedia.org/wiki/%EC%98%A4%ED%94%88_%EC%86%8C%EC%8A%A4 

OSI 
• https://opensource.org/osd 

블랙덕 
• 2014 Future of Open Source Survey Results 
• 2015 Future of Open Source Survey Results 

IDC 
• Worldwide Linux Server Operation System Environment by Vendors, 2006-2010, March IDC 2011 

IT World 
•  http://www.itworld.co.kr/news/97250 

Yahoo Finance 
• http://finance.yahoo.com 

NIPA/MASO 
• 공개SW 성공 사례집 

Polarsys 
• https://www.polarsys.org/ 
